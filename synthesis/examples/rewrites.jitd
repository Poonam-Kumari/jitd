
cog ArrayCog(buffer buff);
cog SortedArrayCog(buffer buff);
cog BTreeCog(cog lhs, cog rhs, record sep);
cog ConcatCog(cog lhs, cog rhs);
cog DeleteCog(cog source, cog deleted);

rule Recur(rule op) is
  | x:ArrayCog       => done
  | x:SortedArrayCog => done
  | BTreeCog(lhs, rhs, sep) => {
      apply op to lhs;
      apply op to rhs
    }
  | ConcatCog(lhs, rhs) => {
      apply op to lhs;
      apply op to rhs
    }
  | DeleteCog(source, deleted) => {
      apply op to source;
      apply op to deleted
    }
;

rule RecurToTarget(rule op, record target) is
  | x:ArrayCog       => done
  | x:SortedArrayCog => done
  | BTreeCog(lhs, rhs, sep) => {
      if( target < sep ) {
        apply op to lhs
      } else {
        apply op to rhs
      }
    }
  | ConcatCog(lhs, rhs) => {
      apply op to lhs;
      apply op to rhs
    }
  | DeleteCog(source, deleted) => {
      apply op to source;
      apply op to deleted
    }
;

rule RecurTopDown(rule op) is 
  | x => {
    apply op to x;
    apply Recur(RecurTopDown(op)) to x
  }
;


rule RecurBottomUp(rule op) is 
  | x => {
    apply Recur(RecurBottomUp(op)) to x;
    apply op to x
  }
;

rule RecurToTargetTopDown(rule op, record target) is 
  | x => {
    apply op to x;
    apply RecurToTarget(RecurToTargetTopDown(op, target), target) to x
  }
;

rule RecurToTargetBottomUp(rule op, record target) is 
  | x => {
    apply RecurToTarget(RecurToTargetBottomUp(op, target), target) to x;
    apply op to x
  }
;

rule SplitArray(record target) is
  | Array(buff) => {
    let auto buff_pair := @{ buff->split(target) };
    let buffer a := @{ buff_pair.first };
    let buffer b := @{ buff_pair.second };
    rewrite BTree(Array(a), Array(b), target)
  }
;

rule SplitArrayRandom is
  | x => {
    let record target := @{ buff->randomElement() };
    apply SplitArray(target) to x
  }
;

rule SortArray is
  | Array(buff) => {
    let buffer sorted := @{ buff->sort() };
    rewrite SortedArray(sorted)
  }
;

rule SplitOrSortArray(int minSize) is
  | x:Array => {
    if ( @{ x->size() } <= minSize ) {
      apply SortArray to x
    } else {
      apply SplitArrayRandom to x
    }
  }
;

policy DumbCracker(int minSize) is
  on BeginIterator(x) => {
    apply SplitOrSortArray(minSize) to x
  }
;